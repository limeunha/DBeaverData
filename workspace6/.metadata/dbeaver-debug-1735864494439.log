2025-01-02 09:21:58.514 - DBeaver 24.2.5.202411171748 is starting
2025-01-02 09:21:58.515 - OS: Windows 10 10.0 (amd64)
2025-01-02 09:21:58.516 - Java version: 17.0.6 by Eclipse Adoptium (64bit)
2025-01-02 09:21:58.516 - Install path: 'C:\Users\EZENIC-038\AppData\Local\DBeaver'
2025-01-02 09:21:58.516 - Instance path: 'file:/C:/Users/EZENIC-038/AppData/Roaming/DBeaverData/workspace6/'
2025-01-02 09:21:58.518 - Memory available 64Mb/1024Mb
2025-01-02 09:21:58.529 - Create display
2025-01-02 09:21:58.679 - Starting instance server at http://localhost:49848
2025-01-02 09:21:58.688 - Run workbench
> Start Eclipse e4 Workbench SWT [org.eclipse.e4.ui.workbench.swt 0.17.500.v20240807-0911]
> Start Eclipse Application Services [org.eclipse.e4.core.services 2.4.400.v20240413-1529]
> Start Eclipse UI Application Services [org.eclipse.e4.ui.services 1.6.300.v20231201-1637]
> Start Eclipse e4 Progress View [org.eclipse.e4.ui.progress 0.4.600.v20240606-1020]
> Start Eclipse Bindings Support [org.eclipse.e4.ui.bindings 0.14.400.v20240321-1245]
> Start Eclipse e4 core commands [org.eclipse.e4.core.commands 1.1.400.v20240424-0444]
> Start EMF XML/XMI Persistence [org.eclipse.emf.ecore.xmi 2.38.0.v20240721-0634]
> Start Eclipse CSS SWT Theme Support [org.eclipse.e4.ui.css.swt.theme 0.14.400.v20240424-0956]
> Start Eclipse e4 Workbench Add-ons [org.eclipse.e4.ui.workbench.addons.swt 1.5.500.v20240620-1945]
> Start Eclipse e4 Workbench SWT Renderer [org.eclipse.e4.ui.workbench.renderers.swt 0.16.500.v20240727-1037]
> Start Eclipse Dependency Injection Extensions [org.eclipse.e4.core.di.extensions 0.18.300.v20240413-1529]
> Start Eclipse CSS SWT Support [org.eclipse.e4.ui.css.swt 0.15.400.v20240321-1245]
> Start Default Text Editor [org.eclipse.ui.editors 3.18.0.v20240807-0735]
> Start Text Editor Framework [org.eclipse.ui.workbench.texteditor 3.18.0.v20240819-1419]
2025-01-02 09:22:00.504 - Configure workbench window
> Start DBeaver SQL Model [org.jkiss.dbeaver.model.sql 1.0.133.202411171748]
2025-01-02 09:22:00.670 - Total database drivers: 120 (120)
> Start Help System Core [org.eclipse.help 3.10.400.v20240415-0528]
2025-01-02 09:22:00.755 - Create actions
2025-01-02 09:22:00.762 - Disable Eclipse action set 'org.eclipse.ui.edit.text.actionSet.annotationNavigation'
2025-01-02 09:22:00.763 - Disable Eclipse action set 'org.eclipse.ui.WorkingSetActionSet'
2025-01-02 09:22:00.763 - Disable Eclipse action set 'org.eclipse.ui.actionSet.openFiles'
2025-01-02 09:22:00.764 - Create workbench actions
2025-01-02 09:22:01.442 - Initialize workbench window
2025-01-02 09:22:01.455 - Finish initialization
> Start DBeaver UI Editors - Data [org.jkiss.dbeaver.ui.editors.data 1.0.143.202411171748]
> Start Internet Connection Management UI [org.eclipse.ui.net 1.5.400.v20240413-1529]
> Start Internet Connection Management [org.eclipse.core.net 1.5.500.v20240625-1706]
Warning: NLS unused message: actions_navigator__objects in: org.jkiss.dbeaver.ui.editors.sql.internal.SQLEditorMessages
> Start DBeaver UI Editors - SQL [org.jkiss.dbeaver.ui.editors.sql 1.0.143.202411171748]
> Start DBeaver Sample Database [org.jkiss.dbeaver.ext.sample.database 1.0.180.202411171748]
> Start DBeaver Tip of the day [org.jkiss.dbeaver.ext.ui.tipoftheday 1.0.149.202411171748]
> Start GEF Classic Draw2d [org.eclipse.draw2d 3.17.0.202409021815]
> Start GEF Classic GEF (MVC) [org.eclipse.gef 3.19.0.202409021815]
> Start DBeaver ERD UI [org.jkiss.dbeaver.erd.ui 3.0.103.202411171748]
> Start DBeaver ERD Model [org.jkiss.dbeaver.erd.model 1.0.103.202411171748]
> Start DBeaver Dashboard UI [org.jkiss.dbeaver.ui.dashboard 1.0.140.202411171748]
> Start DBeaver JDBC Model [org.jkiss.dbeaver.model.jdbc 1.0.36.202411171748]
> Start DBeaver Oracle Model [org.jkiss.dbeaver.ext.oracle 2.1.228.202411171748]
2025-01-02 09:22:03.207 - Connect with 'localhost 2' (mysql8-1939a18f57e-4f6b7c7b789d4747)
> Start DBeaver MySQL Support [org.jkiss.dbeaver.ext.mysql 2.1.228.202411171748]
2025-01-02 09:22:03.284 - Execution context opened (localhost 2; Main; 0)
> Start DBeaver GIS Support [org.jkiss.dbeaver.data.gis 1.0.167.202411171748]
2025-01-02 09:22:03.583 - Execution context opened (localhost 2; Metadata; 1)
2025-01-02 09:22:03.704 - Connected (mysql8-1939a18f57e-4f6b7c7b789d4747, MySQL Connector/J [mysql-connector-j-8.2.0 (Revision: 06a1f724497fd81c6a659131fda822c9e5085b6c)])
2025-01-02 09:22:05.498 - Open [https://dbeaver.io/product/version.xml]
> Start DBeaver SQL Terminal [org.jkiss.dbeaver.ui.editors.sql.terminal 1.0.119.202411171748]
> Start Core Compare Support [org.eclipse.compare.core 3.8.500.v20240524-2010]
> Start Console [org.eclipse.ui.console 3.14.100.v20240429-1358]
> Start Debug Core [org.eclipse.debug.core 3.21.500.v20240801-2219]
2025-01-02 10:45:22.898 - Execution context opened (localhost 2; SQLEditor <Script-13.sql>; 2)
> Start DBeaver SQL Language Semantic Model [org.jkiss.dbeaver.model.lsm 1.0.38.202411171748]
> Start DBeaver Tasks - Native Tools UI [org.jkiss.dbeaver.tasks.native.ui 1.0.121.202411171748]
> Start DBeaver MySQL UI Support [org.jkiss.dbeaver.ext.mysql.ui 1.0.135.202411171748]
> Start DBeaver Tasks - General UI [org.jkiss.dbeaver.tasks.ui 1.0.121.202411171748]
2025-01-02 10:46:44.483 - Can't parse numeric value [const express = require('express')
const multer = require('multer')
const path = require('path')
const fs = require('fs')
const { Diary } = require('../models') // Diary 모델
const { isLoggedIn } = require('../routes/middlewares') // 로그인 미들웨어
const router = express.Router()

const uploadDir = path.join(__dirname, '../uploads')

// uploads 폴더가 없으면 생성
if (!fs.existsSync(uploadDir)) {
   console.log('uploads 폴더가 없어 uploads 폴더를 생성합니다.')
   fs.mkdirSync(uploadDir)
}

// multer 설정
const upload = multer({
   storage: multer.diskStorage({
      destination(req, file, cb) {
         cb(null, uploadDir)
      },
      filename(req, file, cb) {
         const decodedFileName = decodeURIComponent(file.originalname)
         const ext = path.extname(decodedFileName)
         const basename = path.basename(decodedFileName, ext)
         cb(null, basename + Date.now() + ext) // 파일 이름에 타임스탬프 추가
      },
   }),
   limits: { fileSize: 5 * 1024 * 1024 }, // 최대 파일 크기 5MB
})

// 업로드된 파일을 정적 파일로 제공
router.use('/uploads', express.static(uploadDir))

// 다이어리 등록
router.post('/', isLoggedIn, upload.single('img'), async (req, res) => {
   console.log('Logged in user:', req.user)
   console.log('Uploaded file:', req.file)

   try {
      // 파일이 없으면 오류 반환
      if (!req.file) {
         return res.status(400).json({ success: false, message: '파일 업로드에 실패했습니다.' })
      }

      // 로그인 정보가 없으면 오류 반환
      if (!req.user) {
         return res.status(401).json({ success: false, message: '로그인 정보가 없습니다.' })
      }

      // 다이어리 생성
      const diary = await Diary.create({
         title: req.body.title,
         content: req.body.content,
         authorId: req.user.id,
         img: `/uploads/${req.file.filename}`, // 업로드된 이미지 경로 저장
      })

      res.json({
         success: true,
         diary: {
            id: diary.id,
            title: diary.title,
            content: diary.content,
            img: diary.img,
            authorId: diary.authorId,
         },
         message: '다이어리가 성공적으로 등록되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary creation:', error)
      res.status(500).json({ success: false, message: '다이어리 등록 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 수정
router.put('/:id', isLoggedIn, upload.single('img'), async (req, res) => {
   try {
      // 다이어리 찾기 (사용자가 작성한 다이어리만 수정 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 수정할 데이터 준비
      const updatedData = {
         title: req.body.title,
         content: req.body.content,
      }

      if (req.file) {
         // 새 이미지가 업로드되면 이미지 경로 갱신
         updatedData.img = `/uploads/${req.file.filename}`
      }

      // 다이어리 수정
      await diary.update(updatedData)

      res.json({
         success: true,
         diary,
         message: '다이어리가 성공적으로 수정되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary update:', error)
      res.status(500).json({ success: false, message: '다이어리 수정 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 삭제
router.delete('/:id', isLoggedIn, async (req, res) => {
   try {
      console.log('Request received for deleting diary with ID:', req.params.id)

      // 다이어리 찾기 (사용자가 작성한 다이어리만 삭제 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      console.log('Found diary:', diary)

      if (!diary) {
         console.log('Diary not found or user is not the author')
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 이미지 파일 삭제 처리
      if (diary.img) {
         const filePath = path.join(__dirname, '../uploads', diary.img.split('/uploads/')[1])
         console.log('File to delete:', filePath)

         if (fs.existsSync(filePath)) {
            console.log('Deleting file:', filePath)
            fs.unlinkSync(filePath) // 파일 삭제
         } else {
            console.log('File does not exist:', filePath)
         }
      } else {
         console.log('No image associated with this diary')
      }

      // 다이어리 삭제
      await diary.destroy()
      console.log('Diary successfully deleted')

      // 성공 응답
      res.json({
         success: true,
         message: '다이어리가 성공적으로 삭제되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary deletion:', error)
      res.status(500).json({ success: false, message: '다이어리 삭제 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 조회 (ID로)
router.get('/:id', async (req, res) => {
   try {
      const diary = await Diary.findByPk(req.params.id)

      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      res.json({
         success: true,
         diary,
         message: '다이어리를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diary:', error)
      res.status(500).json({ success: false, message: '다이어리를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

// 전체 다이어리 목록 조회 (페이징)
router.get('/', async (req, res) => {
   try {
      const page = parseInt(req.query.page, 10) || 1
      const limit = parseInt(req.query.limit, 10) || 3
      const offset = (page - 1) * limit

      const count = await Diary.count()

      const diaries = await Diary.findAll({
         limit,
         offset,
         order: [['createdAt', 'DESC']], // 최신 순으로 정렬
      })

      res.json({
         success: true,
         diaries,
         pagination: {
            totalDiaries: count,
            currentPage: page,
            totalPages: Math.ceil(count / limit),
            limit,
         },
         message: '전체 다이어리 리스트를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diaries:', error)
      res.status(500).json({ success: false, message: '다이어리 리스트를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

module.exports = router] using formatter: Illegal embedded sign character
2025-01-02 10:46:44.485 - Can't parse numeric value [const express = require('express')
const multer = require('multer')
const path = require('path')
const fs = require('fs')
const { Diary } = require('../models') // Diary 모델
const { isLoggedIn } = require('../routes/middlewares') // 로그인 미들웨어
const router = express.Router()

const uploadDir = path.join(__dirname, '../uploads')

// uploads 폴더가 없으면 생성
if (!fs.existsSync(uploadDir)) {
   console.log('uploads 폴더가 없어 uploads 폴더를 생성합니다.')
   fs.mkdirSync(uploadDir)
}

// multer 설정
const upload = multer({
   storage: multer.diskStorage({
      destination(req, file, cb) {
         cb(null, uploadDir)
      },
      filename(req, file, cb) {
         const decodedFileName = decodeURIComponent(file.originalname)
         const ext = path.extname(decodedFileName)
         const basename = path.basename(decodedFileName, ext)
         cb(null, basename + Date.now() + ext) // 파일 이름에 타임스탬프 추가
      },
   }),
   limits: { fileSize: 5 * 1024 * 1024 }, // 최대 파일 크기 5MB
})

// 업로드된 파일을 정적 파일로 제공
router.use('/uploads', express.static(uploadDir))

// 다이어리 등록
router.post('/', isLoggedIn, upload.single('img'), async (req, res) => {
   console.log('Logged in user:', req.user)
   console.log('Uploaded file:', req.file)

   try {
      // 파일이 없으면 오류 반환
      if (!req.file) {
         return res.status(400).json({ success: false, message: '파일 업로드에 실패했습니다.' })
      }

      // 로그인 정보가 없으면 오류 반환
      if (!req.user) {
         return res.status(401).json({ success: false, message: '로그인 정보가 없습니다.' })
      }

      // 다이어리 생성
      const diary = await Diary.create({
         title: req.body.title,
         content: req.body.content,
         authorId: req.user.id,
         img: `/uploads/${req.file.filename}`, // 업로드된 이미지 경로 저장
      })

      res.json({
         success: true,
         diary: {
            id: diary.id,
            title: diary.title,
            content: diary.content,
            img: diary.img,
            authorId: diary.authorId,
         },
         message: '다이어리가 성공적으로 등록되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary creation:', error)
      res.status(500).json({ success: false, message: '다이어리 등록 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 수정
router.put('/:id', isLoggedIn, upload.single('img'), async (req, res) => {
   try {
      // 다이어리 찾기 (사용자가 작성한 다이어리만 수정 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 수정할 데이터 준비
      const updatedData = {
         title: req.body.title,
         content: req.body.content,
      }

      if (req.file) {
         // 새 이미지가 업로드되면 이미지 경로 갱신
         updatedData.img = `/uploads/${req.file.filename}`
      }

      // 다이어리 수정
      await diary.update(updatedData)

      res.json({
         success: true,
         diary,
         message: '다이어리가 성공적으로 수정되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary update:', error)
      res.status(500).json({ success: false, message: '다이어리 수정 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 삭제
router.delete('/:id', isLoggedIn, async (req, res) => {
   try {
      console.log('Request received for deleting diary with ID:', req.params.id)

      // 다이어리 찾기 (사용자가 작성한 다이어리만 삭제 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      console.log('Found diary:', diary)

      if (!diary) {
         console.log('Diary not found or user is not the author')
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 이미지 파일 삭제 처리
      if (diary.img) {
         const filePath = path.join(__dirname, '../uploads', diary.img.split('/uploads/')[1])
         console.log('File to delete:', filePath)

         if (fs.existsSync(filePath)) {
            console.log('Deleting file:', filePath)
            fs.unlinkSync(filePath) // 파일 삭제
         } else {
            console.log('File does not exist:', filePath)
         }
      } else {
         console.log('No image associated with this diary')
      }

      // 다이어리 삭제
      await diary.destroy()
      console.log('Diary successfully deleted')

      // 성공 응답
      res.json({
         success: true,
         message: '다이어리가 성공적으로 삭제되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary deletion:', error)
      res.status(500).json({ success: false, message: '다이어리 삭제 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 조회 (ID로)
router.get('/:id', async (req, res) => {
   try {
      const diary = await Diary.findByPk(req.params.id)

      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      res.json({
         success: true,
         diary,
         message: '다이어리를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diary:', error)
      res.status(500).json({ success: false, message: '다이어리를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

// 전체 다이어리 목록 조회 (페이징)
router.get('/', async (req, res) => {
   try {
      const page = parseInt(req.query.page, 10) || 1
      const limit = parseInt(req.query.limit, 10) || 3
      const offset = (page - 1) * limit

      const count = await Diary.count()

      const diaries = await Diary.findAll({
         limit,
         offset,
         order: [['createdAt', 'DESC']], // 최신 순으로 정렬
      })

      res.json({
         success: true,
         diaries,
         pagination: {
            totalDiaries: count,
            currentPage: page,
            totalPages: Math.ceil(count / limit),
            limit,
         },
         message: '전체 다이어리 리스트를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diaries:', error)
      res.status(500).json({ success: false, message: '다이어리 리스트를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

module.exports = router] using formatter: Illegal embedded sign character
2025-01-02 10:46:44.517 - Can't parse numeric value [const express = require('express')
const multer = require('multer')
const path = require('path')
const fs = require('fs')
const { Diary } = require('../models') // Diary 모델
const { isLoggedIn } = require('../routes/middlewares') // 로그인 미들웨어
const router = express.Router()

const uploadDir = path.join(__dirname, '../uploads')

// uploads 폴더가 없으면 생성
if (!fs.existsSync(uploadDir)) {
   console.log('uploads 폴더가 없어 uploads 폴더를 생성합니다.')
   fs.mkdirSync(uploadDir)
}

// multer 설정
const upload = multer({
   storage: multer.diskStorage({
      destination(req, file, cb) {
         cb(null, uploadDir)
      },
      filename(req, file, cb) {
         const decodedFileName = decodeURIComponent(file.originalname)
         const ext = path.extname(decodedFileName)
         const basename = path.basename(decodedFileName, ext)
         cb(null, basename + Date.now() + ext) // 파일 이름에 타임스탬프 추가
      },
   }),
   limits: { fileSize: 5 * 1024 * 1024 }, // 최대 파일 크기 5MB
})

// 업로드된 파일을 정적 파일로 제공
router.use('/uploads', express.static(uploadDir))

// 다이어리 등록
router.post('/', isLoggedIn, upload.single('img'), async (req, res) => {
   console.log('Logged in user:', req.user)
   console.log('Uploaded file:', req.file)

   try {
      // 파일이 없으면 오류 반환
      if (!req.file) {
         return res.status(400).json({ success: false, message: '파일 업로드에 실패했습니다.' })
      }

      // 로그인 정보가 없으면 오류 반환
      if (!req.user) {
         return res.status(401).json({ success: false, message: '로그인 정보가 없습니다.' })
      }

      // 다이어리 생성
      const diary = await Diary.create({
         title: req.body.title,
         content: req.body.content,
         authorId: req.user.id,
         img: `/uploads/${req.file.filename}`, // 업로드된 이미지 경로 저장
      })

      res.json({
         success: true,
         diary: {
            id: diary.id,
            title: diary.title,
            content: diary.content,
            img: diary.img,
            authorId: diary.authorId,
         },
         message: '다이어리가 성공적으로 등록되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary creation:', error)
      res.status(500).json({ success: false, message: '다이어리 등록 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 수정
router.put('/:id', isLoggedIn, upload.single('img'), async (req, res) => {
   try {
      // 다이어리 찾기 (사용자가 작성한 다이어리만 수정 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 수정할 데이터 준비
      const updatedData = {
         title: req.body.title,
         content: req.body.content,
      }

      if (req.file) {
         // 새 이미지가 업로드되면 이미지 경로 갱신
         updatedData.img = `/uploads/${req.file.filename}`
      }

      // 다이어리 수정
      await diary.update(updatedData)

      res.json({
         success: true,
         diary,
         message: '다이어리가 성공적으로 수정되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary update:', error)
      res.status(500).json({ success: false, message: '다이어리 수정 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 삭제
router.delete('/:id', isLoggedIn, async (req, res) => {
   try {
      console.log('Request received for deleting diary with ID:', req.params.id)

      // 다이어리 찾기 (사용자가 작성한 다이어리만 삭제 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      console.log('Found diary:', diary)

      if (!diary) {
         console.log('Diary not found or user is not the author')
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 이미지 파일 삭제 처리
      if (diary.img) {
         const filePath = path.join(__dirname, '../uploads', diary.img.split('/uploads/')[1])
         console.log('File to delete:', filePath)

         if (fs.existsSync(filePath)) {
            console.log('Deleting file:', filePath)
            fs.unlinkSync(filePath) // 파일 삭제
         } else {
            console.log('File does not exist:', filePath)
         }
      } else {
         console.log('No image associated with this diary')
      }

      // 다이어리 삭제
      await diary.destroy()
      console.log('Diary successfully deleted')

      // 성공 응답
      res.json({
         success: true,
         message: '다이어리가 성공적으로 삭제되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary deletion:', error)
      res.status(500).json({ success: false, message: '다이어리 삭제 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 조회 (ID로)
router.get('/:id', async (req, res) => {
   try {
      const diary = await Diary.findByPk(req.params.id)

      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      res.json({
         success: true,
         diary,
         message: '다이어리를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diary:', error)
      res.status(500).json({ success: false, message: '다이어리를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

// 전체 다이어리 목록 조회 (페이징)
router.get('/', async (req, res) => {
   try {
      const page = parseInt(req.query.page, 10) || 1
      const limit = parseInt(req.query.limit, 10) || 3
      const offset = (page - 1) * limit

      const count = await Diary.count()

      const diaries = await Diary.findAll({
         limit,
         offset,
         order: [['createdAt', 'DESC']], // 최신 순으로 정렬
      })

      res.json({
         success: true,
         diaries,
         pagination: {
            totalDiaries: count,
            currentPage: page,
            totalPages: Math.ceil(count / limit),
            limit,
         },
         message: '전체 다이어리 리스트를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diaries:', error)
      res.status(500).json({ success: false, message: '다이어리 리스트를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

module.exports = router] using formatter: Illegal embedded sign character
2025-01-02 10:46:44.545 - Can't parse numeric value [const express = require('express')
const multer = require('multer')
const path = require('path')
const fs = require('fs')
const { Diary } = require('../models') // Diary 모델
const { isLoggedIn } = require('../routes/middlewares') // 로그인 미들웨어
const router = express.Router()

const uploadDir = path.join(__dirname, '../uploads')

// uploads 폴더가 없으면 생성
if (!fs.existsSync(uploadDir)) {
   console.log('uploads 폴더가 없어 uploads 폴더를 생성합니다.')
   fs.mkdirSync(uploadDir)
}

// multer 설정
const upload = multer({
   storage: multer.diskStorage({
      destination(req, file, cb) {
         cb(null, uploadDir)
      },
      filename(req, file, cb) {
         const decodedFileName = decodeURIComponent(file.originalname)
         const ext = path.extname(decodedFileName)
         const basename = path.basename(decodedFileName, ext)
         cb(null, basename + Date.now() + ext) // 파일 이름에 타임스탬프 추가
      },
   }),
   limits: { fileSize: 5 * 1024 * 1024 }, // 최대 파일 크기 5MB
})

// 업로드된 파일을 정적 파일로 제공
router.use('/uploads', express.static(uploadDir))

// 다이어리 등록
router.post('/', isLoggedIn, upload.single('img'), async (req, res) => {
   console.log('Logged in user:', req.user)
   console.log('Uploaded file:', req.file)

   try {
      // 파일이 없으면 오류 반환
      if (!req.file) {
         return res.status(400).json({ success: false, message: '파일 업로드에 실패했습니다.' })
      }

      // 로그인 정보가 없으면 오류 반환
      if (!req.user) {
         return res.status(401).json({ success: false, message: '로그인 정보가 없습니다.' })
      }

      // 다이어리 생성
      const diary = await Diary.create({
         title: req.body.title,
         content: req.body.content,
         authorId: req.user.id,
         img: `/uploads/${req.file.filename}`, // 업로드된 이미지 경로 저장
      })

      res.json({
         success: true,
         diary: {
            id: diary.id,
            title: diary.title,
            content: diary.content,
            img: diary.img,
            authorId: diary.authorId,
         },
         message: '다이어리가 성공적으로 등록되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary creation:', error)
      res.status(500).json({ success: false, message: '다이어리 등록 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 수정
router.put('/:id', isLoggedIn, upload.single('img'), async (req, res) => {
   try {
      // 다이어리 찾기 (사용자가 작성한 다이어리만 수정 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 수정할 데이터 준비
      const updatedData = {
         title: req.body.title,
         content: req.body.content,
      }

      if (req.file) {
         // 새 이미지가 업로드되면 이미지 경로 갱신
         updatedData.img = `/uploads/${req.file.filename}`
      }

      // 다이어리 수정
      await diary.update(updatedData)

      res.json({
         success: true,
         diary,
         message: '다이어리가 성공적으로 수정되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary update:', error)
      res.status(500).json({ success: false, message: '다이어리 수정 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 삭제
router.delete('/:id', isLoggedIn, async (req, res) => {
   try {
      console.log('Request received for deleting diary with ID:', req.params.id)

      // 다이어리 찾기 (사용자가 작성한 다이어리만 삭제 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      console.log('Found diary:', diary)

      if (!diary) {
         console.log('Diary not found or user is not the author')
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 이미지 파일 삭제 처리
      if (diary.img) {
         const filePath = path.join(__dirname, '../uploads', diary.img.split('/uploads/')[1])
         console.log('File to delete:', filePath)

         if (fs.existsSync(filePath)) {
            console.log('Deleting file:', filePath)
            fs.unlinkSync(filePath) // 파일 삭제
         } else {
            console.log('File does not exist:', filePath)
         }
      } else {
         console.log('No image associated with this diary')
      }

      // 다이어리 삭제
      await diary.destroy()
      console.log('Diary successfully deleted')

      // 성공 응답
      res.json({
         success: true,
         message: '다이어리가 성공적으로 삭제되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary deletion:', error)
      res.status(500).json({ success: false, message: '다이어리 삭제 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 조회 (ID로)
router.get('/:id', async (req, res) => {
   try {
      const diary = await Diary.findByPk(req.params.id)

      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      res.json({
         success: true,
         diary,
         message: '다이어리를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diary:', error)
      res.status(500).json({ success: false, message: '다이어리를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

// 전체 다이어리 목록 조회 (페이징)
router.get('/', async (req, res) => {
   try {
      const page = parseInt(req.query.page, 10) || 1
      const limit = parseInt(req.query.limit, 10) || 3
      const offset = (page - 1) * limit

      const count = await Diary.count()

      const diaries = await Diary.findAll({
         limit,
         offset,
         order: [['createdAt', 'DESC']], // 최신 순으로 정렬
      })

      res.json({
         success: true,
         diaries,
         pagination: {
            totalDiaries: count,
            currentPage: page,
            totalPages: Math.ceil(count / limit),
            limit,
         },
         message: '전체 다이어리 리스트를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diaries:', error)
      res.status(500).json({ success: false, message: '다이어리 리스트를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

module.exports = router] using formatter: Illegal embedded sign character
2025-01-02 10:46:44.572 - Can't parse numeric value [const express = require('express')
const multer = require('multer')
const path = require('path')
const fs = require('fs')
const { Diary } = require('../models') // Diary 모델
const { isLoggedIn } = require('../routes/middlewares') // 로그인 미들웨어
const router = express.Router()

const uploadDir = path.join(__dirname, '../uploads')

// uploads 폴더가 없으면 생성
if (!fs.existsSync(uploadDir)) {
   console.log('uploads 폴더가 없어 uploads 폴더를 생성합니다.')
   fs.mkdirSync(uploadDir)
}

// multer 설정
const upload = multer({
   storage: multer.diskStorage({
      destination(req, file, cb) {
         cb(null, uploadDir)
      },
      filename(req, file, cb) {
         const decodedFileName = decodeURIComponent(file.originalname)
         const ext = path.extname(decodedFileName)
         const basename = path.basename(decodedFileName, ext)
         cb(null, basename + Date.now() + ext) // 파일 이름에 타임스탬프 추가
      },
   }),
   limits: { fileSize: 5 * 1024 * 1024 }, // 최대 파일 크기 5MB
})

// 업로드된 파일을 정적 파일로 제공
router.use('/uploads', express.static(uploadDir))

// 다이어리 등록
router.post('/', isLoggedIn, upload.single('img'), async (req, res) => {
   console.log('Logged in user:', req.user)
   console.log('Uploaded file:', req.file)

   try {
      // 파일이 없으면 오류 반환
      if (!req.file) {
         return res.status(400).json({ success: false, message: '파일 업로드에 실패했습니다.' })
      }

      // 로그인 정보가 없으면 오류 반환
      if (!req.user) {
         return res.status(401).json({ success: false, message: '로그인 정보가 없습니다.' })
      }

      // 다이어리 생성
      const diary = await Diary.create({
         title: req.body.title,
         content: req.body.content,
         authorId: req.user.id,
         img: `/uploads/${req.file.filename}`, // 업로드된 이미지 경로 저장
      })

      res.json({
         success: true,
         diary: {
            id: diary.id,
            title: diary.title,
            content: diary.content,
            img: diary.img,
            authorId: diary.authorId,
         },
         message: '다이어리가 성공적으로 등록되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary creation:', error)
      res.status(500).json({ success: false, message: '다이어리 등록 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 수정
router.put('/:id', isLoggedIn, upload.single('img'), async (req, res) => {
   try {
      // 다이어리 찾기 (사용자가 작성한 다이어리만 수정 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 수정할 데이터 준비
      const updatedData = {
         title: req.body.title,
         content: req.body.content,
      }

      if (req.file) {
         // 새 이미지가 업로드되면 이미지 경로 갱신
         updatedData.img = `/uploads/${req.file.filename}`
      }

      // 다이어리 수정
      await diary.update(updatedData)

      res.json({
         success: true,
         diary,
         message: '다이어리가 성공적으로 수정되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary update:', error)
      res.status(500).json({ success: false, message: '다이어리 수정 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 삭제
router.delete('/:id', isLoggedIn, async (req, res) => {
   try {
      console.log('Request received for deleting diary with ID:', req.params.id)

      // 다이어리 찾기 (사용자가 작성한 다이어리만 삭제 가능)
      const diary = await Diary.findOne({ where: { id: req.params.id, authorId: req.user.id } })
      console.log('Found diary:', diary)

      if (!diary) {
         console.log('Diary not found or user is not the author')
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      // 이미지 파일 삭제 처리
      if (diary.img) {
         const filePath = path.join(__dirname, '../uploads', diary.img.split('/uploads/')[1])
         console.log('File to delete:', filePath)

         if (fs.existsSync(filePath)) {
            console.log('Deleting file:', filePath)
            fs.unlinkSync(filePath) // 파일 삭제
         } else {
            console.log('File does not exist:', filePath)
         }
      } else {
         console.log('No image associated with this diary')
      }

      // 다이어리 삭제
      await diary.destroy()
      console.log('Diary successfully deleted')

      // 성공 응답
      res.json({
         success: true,
         message: '다이어리가 성공적으로 삭제되었습니다.',
      })
   } catch (error) {
      console.error('Error during diary deletion:', error)
      res.status(500).json({ success: false, message: '다이어리 삭제 중 오류가 발생했습니다.', error: error.message })
   }
})

// 다이어리 조회 (ID로)
router.get('/:id', async (req, res) => {
   try {
      const diary = await Diary.findByPk(req.params.id)

      if (!diary) {
         return res.status(404).json({ success: false, message: '다이어리를 찾을 수 없습니다.' })
      }

      res.json({
         success: true,
         diary,
         message: '다이어리를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diary:', error)
      res.status(500).json({ success: false, message: '다이어리를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

// 전체 다이어리 목록 조회 (페이징)
router.get('/', async (req, res) => {
   try {
      const page = parseInt(req.query.page, 10) || 1
      const limit = parseInt(req.query.limit, 10) || 3
      const offset = (page - 1) * limit

      const count = await Diary.count()

      const diaries = await Diary.findAll({
         limit,
         offset,
         order: [['createdAt', 'DESC']], // 최신 순으로 정렬
      })

      res.json({
         success: true,
         diaries,
         pagination: {
            totalDiaries: count,
            currentPage: page,
            totalPages: Math.ceil(count / limit),
            limit,
         },
         message: '전체 다이어리 리스트를 성공적으로 불러왔습니다.',
      })
   } catch (error) {
      console.error('Error during fetching diaries:', error)
      res.status(500).json({ success: false, message: '다이어리 리스트를 불러오는 중 오류가 발생했습니다.', error: error.message })
   }
})

module.exports = router] using formatter: Illegal embedded sign character
2025-01-02 14:50:15.106 - Event loop exception
java.lang.NullPointerException: Cannot invoke "org.jkiss.dbeaver.model.runtime.DBRProgressMonitor.subTask(String)" because "monitor" is null
	at org.jkiss.dbeaver.erd.ui.layout.GraphLayoutAuto.layout(GraphLayoutAuto.java:63)
	at org.jkiss.dbeaver.erd.ui.layout.DelegatingLayoutManager.layout(DelegatingLayoutManager.java:100)
	at org.eclipse.draw2d.Figure.layout(Figure.java:1204)
	at org.eclipse.draw2d.Figure.validate(Figure.java:2063)
	at java.base/java.util.ArrayList.forEach(Unknown Source)
	at org.eclipse.draw2d.Figure.validate(Figure.java:2064)
	at java.base/java.util.ArrayList.forEach(Unknown Source)
	at org.eclipse.draw2d.Figure.validate(Figure.java:2064)
	at java.base/java.util.ArrayList.forEach(Unknown Source)
	at org.eclipse.draw2d.Figure.validate(Figure.java:2064)
	at java.base/java.util.ArrayList.forEach(Unknown Source)
	at org.eclipse.draw2d.Figure.validate(Figure.java:2064)
	at org.eclipse.draw2d.FreeformViewport$FreeformViewportLayout.calculatePreferredSize(FreeformViewport.java:27)
	at org.eclipse.draw2d.AbstractLayout.getPreferredSize(AbstractLayout.java:106)
	at org.eclipse.draw2d.AbstractHintLayout.getPreferredSize(AbstractHintLayout.java:87)
	at org.eclipse.draw2d.Figure.getPreferredSize(Figure.java:881)
	at org.eclipse.draw2d.ScrollPaneSolver.solve(ScrollPaneSolver.java:77)
	at org.eclipse.draw2d.FigureCanvas.layoutViewport(FigureCanvas.java:312)
	at org.eclipse.draw2d.FigureCanvas$1.notifyValidating(FigureCanvas.java:271)
	at java.base/java.util.ArrayList.forEach(Unknown Source)
	at org.eclipse.draw2d.UpdateManager.fireValidating(UpdateManager.java:124)
	at org.eclipse.draw2d.DeferredUpdateManager.performValidation(DeferredUpdateManager.java:221)
	at org.eclipse.draw2d.DeferredUpdateManager.performUpdate(DeferredUpdateManager.java:194)
	at org.eclipse.draw2d.DeferredUpdateManager$UpdateRequest.run(DeferredUpdateManager.java:46)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4099)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3715)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1042)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:153)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:639)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:339)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:546)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:173)
	at org.jkiss.dbeaver.ui.app.standalone.DBeaverApplication.start(DBeaverApplication.java:293)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:143)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:109)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:439)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:271)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.base/java.lang.reflect.Method.invoke(Unknown Source)
	at org.jkiss.dbeaver.launcher.DBeaverLauncher.invokeFramework(DBeaverLauncher.java:650)
	at org.jkiss.dbeaver.launcher.DBeaverLauncher.basicRun(DBeaverLauncher.java:610)
	at org.jkiss.dbeaver.launcher.DBeaverLauncher.run(DBeaverLauncher.java:1461)
2025-01-02 14:50:16.902 - FK comments_ibfk_1 has already been added, skip
2025-01-02 15:00:35.412 - FK comments_ibfk_1 has already been added, skip
2025-01-02 16:51:40.994 - FK comments_ibfk_1 has already been added, skip
2025-01-02 17:03:04.157 - Can't parse numeric value [GET /auth/status 304 8.375 ms - -] using formatter: Illegal embedded sign character
2025-01-02 17:03:04.157 - Can't parse numeric value [GET /auth/status 304 8.375 ms - -] using formatter: Illegal embedded sign character
2025-01-02 17:03:04.157 - Can't parse numeric value [GET /auth/status 304 8.375 ms - -] using formatter: Illegal embedded sign character
2025-01-02 17:03:04.157 - Can't parse numeric value [GET /auth/status 304 8.375 ms - -] using formatter: Illegal embedded sign character
2025-01-02 17:03:04.157 - Can't parse numeric value [GET /auth/status 304 8.375 ms - -] using formatter: Illegal embedded sign character
2025-01-02 17:04:59.775 - Source or target node not found
2025-01-02 17:43:27.799 - FK comments_ibfk_1 has already been added, skip
> Start DBeaver UI Editors - Connections [org.jkiss.dbeaver.ui.editors.connection 1.0.134.202411171748]
2025-01-02 18:16:31.347 - Execution context closed (localhost 2, 2)
2025-01-02 18:16:31.738 - Dispose navigator model
2025-01-02 18:16:31.774 - DBeaver is stopping
2025-01-02 18:16:31.780 - Stop instance server
2025-01-02 18:16:32.787 - DBeaver shutdown completed
