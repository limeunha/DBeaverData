--1. 서브쿼리

--스칼라 서브쿼리
SELECT t1.STUDENT_NO,
    (SELECT t2.student_name
     FROM ACADEMY_B t2
     WHERE t2.STUDENT_NO = t1.STUDENT_NO) AS NAME
FROM ACADEMY_A t1;

--인라인 뷰
SELECT t1.STUDENT_NO, t2.student_no
FROM ACADEMY_A t1,
(SELECT STUDENT_NO, STUDENT_NAME
FROM ACADEMY_B) t2
WHERE t1.STUDENT_NO = t2.STUDENT_NO;	

--비연관 서브쿼리
SELECT *
FROM ACADEMY_A
WHERE STUDENT_NAME = (SELECT student_name
		             FROM ACADEMY_B
		             WHERE STUDENT_NO  = 1003);

SELECT student_name
FROM ACADEMY_B
WHERE STUDENT_NO  = 1003;

--연관 서브쿼리
SELECT student_no
FROM ACADEMY_A t1
WHERE STUDENT_NAME  = (SELECT t2.student_name
                       FROM ACADEMY_B t2
                       WHERE t2.STUDENT_NO = t1.STUDENT_NO);
                      

--단일행 서브쿼리(행을 하나만 반환)
SELECT *
FROM ACADEMY_A 
WHERE student_name = (SELECT STUDENT_NAME
                      FROM ACADEMY_B 
                      WHERE STUDENT_NO = 1003);


--다중행 서브쿼리(2개 이상의 행을 결과로 가져온다)
                     
--에러발생(다중행을 나타낼때는 부등호 사용불가)
SELECT *
FROM ACADEMY_A
WHERE STUDENT_NAME in (SELECT STUDENT_NAME
                      FROM ACADEMY_B
                      WHERE STUDENT_NO = 1003 OR STUDENT_NO = 1004);
                     
--다중컬럼 서브쿼리(여러개의 컬럼을 반환)
SELECT *
FROM ACADEMY_A
WHERE (STUDENT_NAME,STUDENT_NO) IN (SELECT STUDENT_NAME, STUDENT_NO
                                    FROM ACADEMY_B
                                    WHERE STUDENT_NO = 1003 OR STUDENT_NO = 1004);


-- 2. 뷰
                                   
-- 뷰 생성
-- 기존 테이블 이용해서 만드는 가상 테이블(논리 테이블)
-- create table 로 만드는 테이블은 실제 존재하는 물리 테이블
                
CREATE OR REPLACE VIEW ACADEMY_ALL AS
SELECT * FROM ACADEMY_A;

SELECT * FROM ACADEMY_ALL;

CREATE OR REPLACE  VIEW ACADEMY_STUDENT_NAME AS
SELECT STUDENT_NAME FROM ACADEMY_A;

--무결성 제약조건 위배
--ACADEMY_STUDENT_NAME 기본키가 없으므로 삽입시 SYUDENT_NO이 NULL이 될 가능성이 있음
--기본 테이블(ACADEMY_A)의 기본키 제약조건이 위반될 수 있음.
INSERT INTO ACADEMY_STUDENT_NAME VALUES('김하서');

INSERT INTO ACADEMY_A VALUES(1005, '김하서');
SELECT * FROM ACADEMY_STUDENT_NAME;

CREATE OR REPLACE VIEW ACADEMY_JOIN AS
SELECT T1.STUDENT_NO, T1.STUDENT_NAME
FROM ACADEMY_A T1, ACADEMY_B T2
WHERE T1.STUDENT_NO = T2.STUDENT_NO;

SELECT * FROM ACADEMY_JOIN;

--뷰삭제
DROP VIEW ACADEMY_JOIN;

--에러가 나는 뷰
CREATE OR REPLACE VIEW ACADEMY_JOIN AS
SELECT *
FROM ACADEMY_A T1, ACADEMY_B T2
WHERE T1.STUDENT_NO = T2.STUDENT_NO;

--3.group by, having, order by에는 select 된 컬럼만 사용가능
SELECT TYPE, count(name) AS count
FROM GIFT 
GROUP BY TYPE
HAVING count(NAME) >= 2
ORDER BY TYPE;

--4.

-- 성적 테이블 작성
CREATE TABLE STUDENT_GRADE
(
	STUDENT_ID NUMBER PRIMARY KEY,
	STUDENT_NAME VARCHAR2(20) NOT NULL,
	SCORE NUMBER NOT NULL
);

-- 힉생 성적 데이터 입력
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (1, '이름 1', 391);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (2, '이름 2', 489);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (3, '이름 3', 437);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (4, '이름 4', 339);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (5, '이름 5', 493);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (6, '이름 6', 361);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (7, '이름 7', 470);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (8, '이름 8', 456);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (9, '이름 9', 417);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (10, '이름 10', 391);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (11, '이름 11', 461);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (12, '이름 12', 298);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (13, '이름 13', 443);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (14, '이름 14', 426);
INSERT INTO STUDENT_GRADE (STUDENT_ID, STUDENT_NAME, SCORE) VALUES (15, '이름 15', 383);

SELECT * FROM STUDENT_GRADE;

SELECT STUDENT_NAME, SCORE, RANK() OVER(ORDER BY score DESC) FROM STUDENT_GRADE;
SELECT STUDENT_NAME, SCORE, DENSE_RANK() OVER(ORDER BY score DESC) FROM STUDENT_GRADE;
SELECT STUDENT_NAME, SCORE, ROW_NUMBER() OVER(ORDER BY score DESC) FROM STUDENT_GRADE;

SELECT TYPE, SUM(price) AS sum FROM GIFT GROUP BY TYPE;
SELECT TYPE, price, sum(price) OVER (PARTITION BY TYPE) AS p FROM gift;


--5. 시퀀스

DROP TABLE EMP;

CREATE TABLE EMP (
    NO   NUMBER,
    NAME VARCHAR2(20),
    AGE  NUMBER
);

CREATE SEQUENCE emp_seq
	INCREMENT BY 1 --몇씩 증가를 시킬건지
	START WITH 1 --시작값
	MINVALUE 1 --최소 시작값
	MAXVALUE 9999 --최대 값
	NOCYCLE --최대값에 도달시 시작값 부터 다시 반복할건지 여부
	NOCACHE --
	NOORDER; --요청순서대로 값을 생성할건지 여부

	DROP SEQUENCE emp_seq;
	
--시퀀스 값 사용
SELECT emp_seq.NEXTVAL
FROM DUAL;

--현재 시퀀스 값 확인
SELECT emp_seq.CURRVAL
FROM DUAL;


































